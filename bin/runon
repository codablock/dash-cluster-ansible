#!/usr/bin/env bash

# my_script.sh
#
# Demonstrates:
#   - A required -n <network>
#   - An optional -g <group>
#   - If no -g is given but an extra argument is passed, that's a single-server name
#   - A -c <command> that, if provided, is run via SSH on matching servers
#   - Minimal example with regex-based inventory parsing

###############################################################################
# 1) Parse Arguments (getopts + leftover args)
###############################################################################

NETWORK=""
GROUP=""
COMMAND=""

usage() {
  echo "Usage: $0 -n <network> [ -g <group> ] [ <server> ] [ -c <command> ]"
  echo
  echo "Examples:"
  echo "  $0 -n testnet -g hp-masternodes -c \"echo 'Hello group' && hostname\""
  echo "  $0 -n testnet hp-masternode-4 -c \"sudo hostnamectl set-hostname hp-masternode-4\""
  echo "  $0 -n testnet -c \"echo 'Hello all'\"  (runs on everything, if so coded)"
  exit 1
}

# Parse the flags -n, -g, -c
while getopts ":n:g:c:" opt; do
  case "$opt" in
    n) NETWORK="$OPTARG" ;;
    g) GROUP="$OPTARG"   ;;
    c) COMMAND="$OPTARG" ;;
    *) usage ;;
  esac
done
shift $((OPTIND - 1))

# Check required network
if [[ -z "$NETWORK" ]]; then
  echo "Error: You must specify -n <network>."
  usage
fi

# Now, if there's anything left in "$@", that might be the single server argument
SERVER="$1"   # If user typed "hp-masternode-4" after the flags

###############################################################################
# 2) Determine which inventory file to use
###############################################################################

INVENTORY_FILE="./networks/${NETWORK}.inventory"
if [[ ! -f "$INVENTORY_FILE" ]]; then
  echo "Error: Inventory file does not exist: $INVENTORY_FILE"
  exit 1
fi

echo "Network:        $NETWORK"
echo "Inventory file: $INVENTORY_FILE"
echo "Group (-g):     $GROUP"
echo "Server arg:     $SERVER"
echo "Command (-c):   $COMMAND"

###############################################################################
# 3) Figure out what pattern to grep for
###############################################################################
# Cases:
#   1) If we have -g <group>, we assume it's a group name like "hp-masternodes".
#      If it ends with "s", we strip it -> "hp-masternode" => match multiple lines.
#   2) If we have no -g but do have $SERVER (like "hp-masternode-4"), we match only that line.
#   3) If neither is present, optionally match ALL "hp-masternode-" lines (or do nothing).

REGEX=""
if [[ -n "$GROUP" ]]; then
  # => group logic
  if [[ "$GROUP" == *s ]]; then
    # Remove trailing 's'
    BASE_NAME="${GROUP::-1}"   # "hp-masternodes" => "hp-masternode"
  else
    BASE_NAME="$GROUP"
  fi
  # We'll match any line that starts with "hp-masternode-<digits>"
  # (and possibly "ansible" if your lines contain that).
  REGEX="^${BASE_NAME}-[0-9]{1,3}\s+ansible"
  echo "Using group-based pattern: $REGEX"
elif [[ -n "$SERVER" ]]; then
  # => single server logic
  # If user typed "hp-masternode-4", we match exactly that node in the line
  REGEX="^${SERVER}\s+ansible"
  echo "Using single-server pattern: $REGEX"
else
  # => no -g, no server => run on everything? or show usage?
  # Here, let's assume we want "hp-masternode-" lines:
  REGEX="^hp-masternode-[0-9]{1,3}\s+ansible"
  echo "No group/server specified, matching all nodes: $REGEX"
fi

# If there's still no pattern, bail out
if [[ -z "$REGEX" ]]; then
  echo "Error: Could not determine a valid grep pattern."
  exit 1
fi

###############################################################################
# 4) Read matching lines from inventory
###############################################################################

readarray -t MATCHES < <( grep -E "$REGEX" "$INVENTORY_FILE" )

echo "Found ${#MATCHES[@]} matching line(s)."

###############################################################################
# 5) Parse each matched line for ansible_host, ansible_user, then SSH
###############################################################################

for line in "${MATCHES[@]}"; do
  echo
  echo "Line: $line"

  # Example parse for ansible_host, ansible_user
  ANSIBLE_HOST=$(echo "$line" \
    | grep -o "ansible_host=[^[:space:]]*" \
    | cut -d"=" -f2)

  ANSIBLE_USER=$(echo "$line" \
    | grep -o "ansible_user='[^']*" \
    | cut -d"'" -f2)
  [[ -z "$ANSIBLE_USER" ]] && ANSIBLE_USER="ubuntu"

  echo "  -> Host: $ANSIBLE_HOST"
  echo "  -> User: $ANSIBLE_USER"

  # If a command was provided, run it via SSH
  if [[ -n "$COMMAND" ]]; then
    echo "  -> Running: $COMMAND"
    ssh -o StrictHostKeyChecking=no \
        -i ~/.ssh/evo-app-deploy.rsa \
        "${ANSIBLE_USER}@${ANSIBLE_HOST}" \
        "bash -c '$COMMAND'" \
        < /dev/null
  fi
done

echo
echo "Done."
exit 0